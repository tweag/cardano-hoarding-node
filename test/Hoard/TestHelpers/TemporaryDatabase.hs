module Hoard.TestHelpers.TemporaryDatabase
  ( DBInfo (..),
    withTmpDB,

    -- * Low level APIs
    createTmpDB,
    dropTmpDB,
    newRole,
    dropRole,
    newDB,
    dropDB,
  )
where

import Control.Exception (Exception, bracket, throwIO)
import Data.ByteString (ByteString)
import Data.String.Conversions (cs)
import Data.Text (Text, pack)
import Hasql.Decoders qualified as Decoders
import Hasql.Encoders qualified as Encoders
import Hasql.Pool qualified as Pool
import Hasql.Session (Session, statement)
import Hasql.Statement (Statement (..))
import Type.Reflection (Typeable)

-- | The data necessary to connect to the temporary database
data DBInfo = DBInfo
  { dbName :: Text,
    roleName :: Text
  }
  deriving (Show, Read, Eq, Ord)

newtype DBException a = DBException a
  deriving (Show)

instance (Show a, Typeable a) => Exception (DBException a)

runOrThrow :: Pool.Pool -> Session a -> IO a
runOrThrow pool sess =
  Pool.use pool sess
    >>= \case
      Left e -> throwIO $ DBException e
      Right a -> pure a

-- | Create a temporary database and a temporary role that the
-- callback can operate on. After the action has finished the database
-- and the role are destroyed.
--
-- This is a `bracket`-style wrapper around 'createTmpDB' and 'dropTmpDB'
--
-- This function assumes that the connection string points to a
-- database containing the tables called @pg_roles@ and @pg_database@
-- and that the user has the @CREATEDB@ and @CREATEROLE@ privileges.
withTmpDB :: Text -> Pool.Pool -> (DBInfo -> IO a) -> IO a
withTmpDB name pool =
  bracket
    (runOrThrow pool (createTmpDB name))
    (Pool.use pool . dropTmpDB)

-- | Create a temporary database and a temporary role.
--
-- To destroy the database and the role use `dropTmpDB`.
--
-- This function assumes that the connection points to a
-- database containing the tables called @pg_roles@ and @pg_database@
-- and that the user has the @CREATEDB@ and @CREATEROLE@ privileges.
createTmpDB :: Text -> Session DBInfo
createTmpDB name = do
  role <- newRole
  newDB name role
  pure $ DBInfo {dbName = name, roleName = role}

-- | Destroy the database and the role created by `createTmpDB`.
dropTmpDB :: DBInfo -> Session ()
dropTmpDB (DBInfo db role) = do
  dropDB db
  dropRole role

-- | Create a new role that does not already exist and return its name.
--
-- The new role does not have a password and has the @CREATEDB@
-- privilege. The database that the connection points to is assumed to
-- contain a table called @pg_roles@ with a @rolname@ column.
newRole :: Session Text
newRole = do
  roles <- statement () queryRoles
  let newName = freshName "tmp" roles
  _ <- statement () (createUser newName)
  pure newName
  where
    queryRoles :: Statement () [Text]
    queryRoles =
      prepared
        "SELECT rolname FROM pg_roles"
        mempty
        (decodeOne Decoders.text)
    createUser :: Text -> Statement () ()
    createUser userName =
      adHoc
        -- apparently, a prepared argument can't be used hereâ€½
        ("CREATE USER " <> cs userName <> " WITH CREATEDB")

decodeOne :: Decoders.Value a -> Decoders.Result [a]
decodeOne val = Decoders.rowList $ Decoders.column $ Decoders.nonNullable val

-- Run an unprepared, ad-hoc statement with no variables
adHoc :: ByteString -> Statement a ()
adHoc sql = Statement sql mempty Decoders.noResult False

-- Run a prepared statement with parameters and return values
prepared :: ByteString -> Encoders.Params a -> Decoders.Result b -> Statement a b
prepared sql enc dec = Statement sql enc dec True

-- | Drop the role.
dropRole :: Text -> Session ()
dropRole name =
  statement () $
    adHoc
      ("DROP ROLE " <> cs name)

-- | Create a new database that is owned by the user.
newDB :: Text -> Text -> Session ()
newDB name role = do
  statement () createDatabase
  where
    createDatabase =
      adHoc
        -- same as above, database name can't be interpolated
        ( "CREATE DATABASE "
            <> cs name
            <> " OWNER "
            <> cs role
        )

-- | Drop the database.
dropDB :: Text -> Session ()
dropDB name =
  statement () $
    adHoc
      ("DROP DATABASE " <> cs name <> " WITH (FORCE)")

-- | Create a fresh name that is not in the list of already existing names.
--
-- The fresh name is generated by appending a number to the supplied
-- template.
freshName :: Text -> [Text] -> Text
freshName template existingNames = loop 0
  where
    -- We could use a Set here to speed up the lookup, however the
    -- construction of that Set is linear as well so it would only pay off
    -- if at least one of the lookups fails.
    loop :: Int -> Text
    loop i =
      if (template <> pack (show i)) `elem` existingNames
        then loop (i + 1)
        else template <> pack (show i)
